<!-- auto-generate scripting documentation (kwrite-devel@kde.org Re: [kate] doc/kate: document most of the new scripts in 4.10) -->
<chapter id="dev">
<chapterinfo>
<authorgroup>
<author
>&TC.Hollingsworth; &TC.Hollingsworth.mail;</author>
<othercredit role="translator"
><firstname
>Nicola</firstname
> <surname
>Ruggero</surname
> <affiliation
><address
><email
>nicola@nxnt.org</email
></address
></affiliation
><contrib
>Traduzione della documentazione.</contrib
></othercredit
><othercredit role="translator"
><firstname
>Luciano</firstname
><surname
>Montanaro</surname
><affiliation
><address
><email
>mikelima@cirulla.net</email
></address
></affiliation
><contrib
>Aggiornamento per Kate 2.5.6</contrib
></othercredit
><othercredit role="translator"
><firstname
>Paolo</firstname
><surname
>Zamponi</surname
><affiliation
><address
><email
>zapaolo@email.it</email
></address
></affiliation
><contrib
>Aggiornamento e manutenzione della traduzione</contrib
></othercredit
> 
</authorgroup>
</chapterinfo>
<title
>Estensione di &katepart;</title>

<sect1 id="dev-intro">
<title
>Introduzione</title>

<para
>Come ogni componente editor di testi avanzato, &katepart; offre una moltitudine di modi per espandere le proprie funzionalità: puoi <link linkend="dev-scripting"
>scrivere semplici script per aggiungere funzionalità con javaScript</link
>. Infine, dopo aver esteso &katepart; saresti il benvenuto <ulink url="http://kate-editor.org/join-us/"
>nel nostro gruppo</ulink
>, per condividere il tuo lavoro con il mondo intero!</para>

</sect1>

<sect1 id="highlight">
<title
>Lavorare con l'evidenziazione della sintassi</title>

<sect2 id="highlight-overview">

<title
>Panoramica</title>

<para
>L'evidenziazione della sintassi è quel qualcosa che rende l'editor in grado di visualizzare automaticamente il testo con stili e colori differenti, a seconda delle funzioni delle stringhe in relazione allo scopo del file. Nel sorgente di un programma, per esempio, le istruzioni di controllo potrebbero essere rese in grassetto, mentre i tipi di dati e i commenti in colori diversi dal resto del testo. Questo migliora di molto la leggibilità del testo, e rende l'autore più efficiente e più produttivo.</para>

<mediaobject>
<imageobject
><imagedata format="PNG" fileref="highlighted.png"/></imageobject>
<textobject
><phrase
>Una funzione Perl, resa con l'evidenziazione della sintassi.</phrase
></textobject>
<caption
><para
>Una funzione Perl, resa con l'evidenziazione della sintassi.</para>
</caption>
</mediaobject>

<mediaobject>
<imageobject
><imagedata format="PNG" fileref="unhighlighted.png"/></imageobject>
<textobject
><phrase
>La stessa funzione Perl, senza l'evidenziazione.</phrase
></textobject>
<caption
><para
>La stessa funzione Perl, senza l'evidenziazione.</para
></caption>
</mediaobject>

<para
>Dei due esempi, qual è il più semplice da leggere?</para>

<para
>&kappname; nasce con un sistema, flessibile, configurabile e in grado di eseguire l'evidenziazione della sintassi. Nella distribuzione standard sono fornite definizioni per una vasta gamma di linguaggi di programmazione, di scripting e di markup, e per altri formati di file di testo; inoltre puoi inserire le tue definizioni in un semplice file &XML;.</para>

<para
>Quando apri un file basato sul tipo &MIME; del file &kappname; riconoscerà automaticamente le giuste regole della sintassi; questo in base alla sua estensione o, se assente, al suo contenuto. Puoi sempre impostare manualmente la sintassi da usare qualora notassi dei problemi, facendo clic su <menuchoice
><guimenu
>Strumenti</guimenu
><guisubmenu
>Evidenziazione</guisubmenu
></menuchoice
>.</para>

<para
>Gli stili e i colori usati da ciascuna definizione di evidenziazione della sintassi possono essere configurati usando la scheda <link linkend="prefcolors-highlighting-text-styles"
>Stili di testo evidenziato</link
>, mentre i tipi &MIME; e le estensioni del file che dovrebbero essere usate a questo scopo sono gestiti nella scheda <link linkend="pref-open-save-modes-filetypes"
>Modi e tipi di file</link
>.</para>

<note>
<para
>L'evidenziazione della sintassi serve per migliorare la leggibilità del testo, ma non puoi affidarti ad essa per convalidarlo. La marcatura del testo in base alla sintassi può essere difficoltosa a seconda del formato che si sta utilizzando, e in qualche caso l'autore delle regole della sintassi sarà orgoglioso qualora il 98% del testo venga correttamente renderizzato. Tuttavia, in genere, sarà difficile incontrare quel 2% non corretto.</para>
</note>

<tip>
<para
>Puoi scaricare le regole di evidenziazione della sintassi aggiornate o aggiuntive dal sito web di &kappname;; fai clic sul pulsante <guibutton
>Scarica i file delle evidenziazioni...</guibutton
> che si trova nella scheda <link linkend="pref-open-save-modes-filetypes"
>Modi e tipi di file</link
> della <link linkend="config-dialog"
>Finestra di configurazione</link
>.</para>
</tip>

</sect2>

<sect2 id="katehighlight-system">

<title
>Il sistema di evidenziazione della sintassi di &kappname;</title>

<para
>In questa sezione sarà trattato più in dettaglio il meccanismo di evidenziazione della sintassi. Ti servirà se vorrai saperne di più, oppure se vorrai cambiare o creare delle definizioni di sintassi.</para>

<sect3 id="katehighlight-howitworks">

<title
>Come funziona</title>

<para
>Una delle prime cose che l'editor &kappname; fa ogni volta che apri un file è quella di individuare quale sia la definizione di sintassi da usare. Mentre stai leggendo il testo del file, e mentre ci stai digitando qualcosa, il sistema di evidenziazione della sintassi analizza il testo usando le regole definite dalle definizioni di sintassi, e lo marca dove i diversi contesti e gli stili iniziano e finiscono.</para>

<para
>Quando digiti nel documento il nuovo testo viene analizzato e marcato al volo. Cosicché, se cancelli un carattere che è marcato come inizio o fine di un contesto, lo stile del testo circostante viene cambiato di conseguenza.</para>

<para
>Le definizioni di sintassi usate dal sistema di evidenziazione di &kappname; sono file &XML;, che contengono <itemizedlist>
<listitem
><para
>Regole per individuare il ruolo del testo, organizzate in blocchi di contesto</para
></listitem>
<listitem
><para
>Liste di parole chiave</para
></listitem>
<listitem
><para
>Definizioni di oggetti di stile</para
></listitem>
</itemizedlist>
</para>

<para
>Quando il testo viene analizzato le regole di rilevamento sono valutate nell'ordine in cui sono definite, e, qualora l'inizio della stringa corrente coincida con una regola, viene usato il contesto relativo. Il punto di inizio del testo viene spostato nel punto finale in cui la regola è stata applicata, e inizia così un nuovo ciclo, che comincia nel contesto impostato dalla regola applicata.</para>

</sect3>

<sect3 id="highlight-system-rules">
<title
>Regole</title>

<para
>Le regole di rilevamento sono il cuore del sistema di rilevamento della sintassi. Una regola è una stringa, un carattere o un'<link linkend="regular-expressions"
>espressione regolare</link
> con cui confrontare il testo che viene analizzato. Contiene informazioni sullo stile da usare per la parte corrispondente del testo. Può passare il contesto di lavoro del sistema sia ad un contesto menzionato esplicitamente che al precedente contesto usato dal testo.</para>

<para
>Le regole sono organizzate in gruppi di contesto, ciascuno dei quali viene usato per i concetti principali di testo all'interno del formato, per esempio le stringhe di testo virgolettato o i blocchi di commenti nei sorgenti dei programmi. Questo assicura che il sistema di evidenziazione non abbia necessità di cercare tra le regole se non è necessario, e che alcune sequenze di caratteri nel testo possono essere trattate in maniera diversa a seconda del contesto corrente. </para>

<para
>I contesti possono essere generati dinamicamente per permettere l'uso di istanze di dati specifici nelle regole.</para>

</sect3>

<sect3 id="highlight-context-styles-keywords">
<title
>Stili di contesto e parole chiave</title>

<para
>In alcuni linguaggi di programmazione i numeri interi sono trattati dal compilatore (il programma che converte il codice sorgente in binario eseguibile) in maniera diversa da quelli in virgola mobile, e all'interno di una stringa virgolettata ci possono essere dei caratteri con un significato speciale. In questi casi ha senso visualizzarli in modo differente da quelli circostanti, in modo che possano essere identificati facilmente durante la lettura del testo. Così, pur non rappresentando un contesto speciale, questi possono essere comunque trattati come tali dal sistema di evidenziazione della sintassi, in modo da essere contrassegnati e quindi visualizzati in modo diverso.</para>

<para
>Una definizione di sintassi può contenere tutti gli stili richiesti per racchiudere i concetti del formato per cui è usata.</para>

<para
>In molti formati ci sono liste di parole che rappresentano un concetto specifico: per esempio nei linguaggi di programmazione le istruzioni di controllo sono un concetto, i nomi dei tipi di dato un altro, e le funzioni proprie del linguaggio un terzo. Il sistema di evidenziazione della sintassi di &kappname; può usare queste liste per individuare le parole marcandole nel testo, in modo da enfatizzare i concetti dei formati di testo.</para>

</sect3>

<sect3 id="kate-highlight-system-default-styles">
<title
>Stili predefiniti</title>

<para
>Se apri un file sorgente in C++, un sorgente &Java; e un documento <acronym
>HTML</acronym
> in &kappname; vedrai che, anche se i formati e le parole scelte per il trattamento speciale sono diversi, i colori utilizzati sono gli stessi. Questo succede perché &kappname; ha una lista di stili predefiniti che sono impiegati dalle definizioni individuali di sintassi.</para>

<para
>Questo rende semplice riconoscere concetti simili in formati di testo diversi. Per esempio, i commenti sono presenti in quasi tutti i linguaggi di programmazione, di scripting e di markup: se sono sempre renderizzati utilizzando lo stesso stile in tutti i linguaggi non avrai bisogno di fermarti a pensare per identificarli nel testo.</para>

<tip>
<para
>Tutti gli stili di una definizione di sintassi usano uno degli stili predefiniti: solo poche definizioni di sintassi fanno usa di altri non predefiniti. Potrebbe valer la pena lanciare la finestra di configurazione se usi spesso un formato, per vedere se alcuni concetti fanno uso di uno stesso stile. Per esempio, c'è solo uno stile predefinito per le stringhe, ma il linguaggio di programmazione Perl opera con due: potresti quindi migliorarne l'evidenziazione configurandole in modo che siano leggermente diverse. Tutti gli <link linkend="kate-highlight-default-styles"
>stili predefiniti disponibili</link
> saranno spiegati in seguito.</para>
</tip>

</sect3>

</sect2>

<sect2 id="katehighlight-xml-format">
<title
>Il formato &XML; di definizione dell'evidenziazione</title>

<sect3>
<title
>Panoramica</title>

<para
>&kappname; usa l'infrastruttura di evidenziazione della sintassi di &kde-frameworks;. I file xml per l'evidenziazione predefinita forniti insieme a &kappname; sono compilati in modo predefinito nella libreria di evidenziazione della sintassi. </para>

<para
>Questa sezione è una panoramica sul formato &XML; di definizione dell'evidenziazione. Basandosi su un piccolo esempio saranno descritti i componenti principali, il loro significato e il loro uso. La prossima sezione scenderà invece nei dettagli delle regole di rilevamento dell'evidenziazione.</para>

<para
>La definizione formale, anche conosciuta come <acronym
>XSD</acronym
>, si trova nel <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema"
>deposito dell'evidenziazione della sintassi</ulink
>, nel file <filename
>language.xsd</filename
> </para>

<para
>I file <filename class="extension"
>.xml</filename
> per la definizione personalizzata di evidenziazione si trovano in <filename class="directory"
>org.kde.syntax-highlighting/syntax/</filename
> nella tua cartella utente, e vengono trovati con <userinput
><command
>qtpaths</command
><option
>--paths GenericDataLocation</option
></userinput
>, che generalmente è <filename class="directory"
><envar
>$HOME</envar
>/.local/share</filename
> </para>

<para
>In &Windows; questi file si trovano in <filename
>%USERPROFILE%/AppData/Local/org.kde.syntax-highlighting/syntax</filename
>. <replaceable
>%USERPROFILE%</replaceable
> viene generalmente espanso in <filename
>C:\\Users\\<replaceable
>utente</replaceable
></filename
>.</para>

<variablelist>
<title
>Le sezioni principali dei file di definizione dell'evidenziazione di &kappname;</title>

<varlistentry>
<term
>Un file di evidenziazione contiene un'intestazione che imposta la versione XML:</term>
<listitem>
<programlisting
>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term
>Il file di definizione inizia con l'elemento <userinput
>language</userinput
>. Gli attributi disponibili sono:</term>

<listitem>
<para
>Attributi richiesti:</para>
<para
><userinput
>name</userinput
> imposta il nome del linguaggio. Appare successivamente nei menu e nelle finestre.</para>
<para
><userinput
>section</userinput
> specifica la categoria.</para>
<para
><userinput
>extensions</userinput
> definisce le estensioni dei file, come &quot;*.cpp;*.h&quot;</para>
<para
><userinput
>version</userinput
> specifica l'attuale revisione del file di definizione in termini di un numero intero; sii certo di incrementare questo numero se cambi un file di definizione dell'evidenziazione.</para>
<para
><userinput
>kateversion</userinput
> specifica l'ultima versione supportata di &kappname;.</para>

<para
>Attributi opzionali:</para>
<para
><userinput
>mimetype</userinput
> associa i tipi &MIME; dei file.</para>
<para
><userinput
>casesensitive</userinput
> definisce se le parole chiave sono sensibili alle maiuscole oppure no.</para>
<para
><userinput
>priority</userinput
> è necessaria se un'altra definizione di evidenziazione usa le stesse estensioni; vince quella con priorità più alta.</para>
<para
><userinput
>author</userinput
> contiene il nome dell'autore e il suo indirizzo di posta elettronica.</para>
<para
><userinput
>license</userinput
> contiene la licenza, di solito MIT, per i nuovi file di evidenziazione della sintassi.</para>
<para
><userinput
>style</userinput
> contiene il linguaggio fornito, ed è usato dai rientratori per gli attributi <literal
>required-syntax-style</literal
>.</para>
<para
><userinput
>hidden</userinput
> definisce se il nome deve apparire nei menu di &kappname;.</para>
<para
>Allora la prossima riga potrebbe apparire così:</para>
<programlisting
>&lt;language name=&quot;C++&quot; version=&quot;1&quot; kateversion=&quot;2.4&quot; section=&quot;Sources&quot; extensions=&quot;*.cpp;*.h&quot; /&gt;
</programlisting>
</listitem>
</varlistentry>


<varlistentry>
<term
>Viene poi l'elemento <userinput
>highlighting</userinput
>, che contiene l'elemento opzionale <userinput
>list</userinput
>, e i richiesti <userinput
>contexts</userinput
> e <userinput
>itemDatas</userinput
>.</term>
<listitem>
<para
>L'elemento <userinput
>list</userinput
> contiene una lista di parole chiave; in questo caso le parole chiave sono <emphasis
>class</emphasis
> e <emphasis
>const</emphasis
>; puoi aggiungere tutte le liste di cui hai bisogno.</para>
<para
>L'elemento <userinput
>contexts</userinput
> contiene tutti i contesti; il primo è di default l'inizio dell'evidenziazione. Ci sono due regole nel contesto <emphasis
>Normal Text</emphasis
>, una associa la lista delle parole chiave con nome <emphasis
>somename</emphasis
>, e un'altra rileva una virgoletta, passando il contesto a <emphasis
>string</emphasis
>. Per saperne di più leggi il prossimo capitolo.</para>
<para
>La terza parte è l'elemento <userinput
>itemDatas</userinput
>: contiene tutti i colori e gli stili dei caratteri che sono necessari per il contesto e per le regole. In questo esempio vengono usati <userinput
>itemData</userinput
> <emphasis
>Normal Text</emphasis
>, <emphasis
>String</emphasis
> e <emphasis
>Keyword</emphasis
>. </para>
<programlisting
>&lt;highlighting&gt;
    &lt;list name=&quot;somename&quot;&gt;
      &lt;item&gt; class &lt;/item&gt;
      &lt;item&gt; const &lt;/item&gt;
    &lt;/list&gt;
    &lt;contexts&gt;
      &lt;context attribute=&quot;Normal Text&quot; lineEndContext=&quot;#pop&quot; name=&quot;Normal Text&quot; &gt;
        &lt;keyword attribute=&quot;Keyword&quot; context=&quot;#stay&quot; String=&quot;somename&quot; /&gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;string&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
      &lt;context attribute=&quot;String&quot; lineEndContext=&quot;#stay&quot; name=&quot;string&quot; &gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;#pop&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
    &lt;/contexts&gt;
    &lt;itemDatas&gt;
      &lt;itemData name=&quot;Normal Text&quot; defStyleNum=&quot;dsNormal&quot; /&gt;
      &lt;itemData name=&quot;Keyword&quot; defStyleNum=&quot;dsKeyword&quot; /&gt;
      &lt;itemData name=&quot;String&quot; defStyleNum=&quot;dsString&quot; /&gt;
    &lt;/itemDatas&gt;
  &lt;/highlighting&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term
>L'ultima parte di una definizione di evidenziazione è la sezione opzionale <userinput
>general</userinput
>. Può contenere informazioni sulle parole chiave, il raggruppamento del codice, i commenti e i rientri.</term>

<listitem>
<para
>La sezione <userinput
>comment</userinput
> definisce con quale stringa viene introdotta una singola riga di commento. Puoi anche definire un commento multi-riga usando <emphasis
>multiLine</emphasis
> con l'attributo addizionale <emphasis
>end</emphasis
>. Questo viene usato se l'utente preme la scorciatoia per <emphasis
>commentare/non commentare</emphasis
>.</para>
<para
>La sezione <userinput
>keywords</userinput
> definisce se la lista delle parole chiave è sensibile alle maiuscole oppure no. Altri attributi verranno spiegati più tardi.</para>
<programlisting
>&lt;general&gt;
    &lt;comments&gt;
      &lt;comment name="singleLine" start="#"/&gt;
    &lt;/comments&gt;
    &lt;keywords casesensitive="1"/&gt;
  &lt;/general&gt;
&lt;/language&gt;
</programlisting>
</listitem>
</varlistentry>

</variablelist>


</sect3>

<sect3 id="kate-highlight-sections">
<title
>Le sezioni in dettaglio</title>
<para
>Questa parte descriverà tutti gli attributi disponibili per contexts, itemDatas, keywords, comments, il raggruppamento del codice e i rientri.</para>

<variablelist>
<varlistentry>
<term
>L'elemento <userinput
>context</userinput
> appartiene al gruppo <userinput
>contexts</userinput
>. Di per sé un contesto definisce le regole specifiche del contesto, tipo cosa dovrebbe accadere qualora il sistema di evidenziazione raggiunga il fine riga. Gli attributi disponibili sono:</term>


<listitem>
<para
><userinput
>name</userinput
> dichiara il nome del contesto. Le regole faranno uso di questo nome per specificare il contesto al quale passare se la regola viene soddisfatta.</para>
<para
><userinput
>lineEndContext</userinput
> definisce il contesto a cui il sistema di evidenziazione passa se viene raggiunta la fine della riga. Questo può essere sia il nome di un altro contesto, <userinput
>#stay</userinput
> per non lasciare il contesto (&eg;. non fare niente), oppure <userinput
>#pop</userinput
>, che causerà l'abbandono di questo contesto. È possibile usare per esempio <userinput
>#pop#pop#pop</userinput
> per saltare tre volte, o anche <userinput
>#pop#pop!OtherContext</userinput
> per saltare due volte e passare al contesto chiamato <userinput
>OtherContext</userinput
>.</para>
<para
><userinput
>lineEmptyContext</userinput
> definisce il contesto se viene incontrata una riga vuota. Predefinito: #stay.</para>
<para
><userinput
>fallthrough</userinput
> definisce se il sistema di evidenziazione deve passare al contesto specificato in fallthroughContext qualora nessuna regola venga soddisfatta. Predefinito: <emphasis
>false</emphasis
>.</para>
<para
><userinput
>fallthroughContext</userinput
> specifica il prossimo contesto se nessuna regola viene soddisfatta.</para>
<para
>Se <userinput
>dynamic</userinput
> è <emphasis
>true</emphasis
> il contesto si ricorderà delle stringhe e dei segnaposti salvati dalle regole dinamiche. Questo serve per esempio nei documenti HERE. Predefinito: <emphasis
>false</emphasis
>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>L'elemento <userinput
>itemData</userinput
> appartiene al gruppo <userinput
>itemDatas</userinput
>. Definisce lo stile del carattere e i colori, e quindi è possibile definire i propri stili e i propri colori. Raccomandiamo però di attenersi agli stili predefiniti, se possibile, cosicché gli utenti vedranno sempre gli stessi colori anche in linguaggi diversi. Tuttavia a volte non c'è altro modo se non quello di cambiare i colori e gli attributi dei caratteri. Sono richiesti il nome degli attributi e StileNumDef, ma gli altri sono opzionali. Gli attributi disponibili sono:</term>

<listitem>
<para
><userinput
>name</userinput
> imposta il nome di itemData. I contesti e le regole useranno questo nome nei loro attributi <emphasis
>attribute</emphasis
> a cui fa riferimento itemData.</para>
<para
><userinput
>defStyleNum</userinput
> definisce quale stile predefinito usare. Gli stili predefiniti disponibili sono spiegati in dettaglio più tardi.</para>
<para
><userinput
>color</userinput
> definisce un colore. Sono validi i formati «#rrggbb» o «#rgb».</para>
<para
><userinput
>selColor</userinput
> definisce la selezione del colore.</para>
<para
>Il testo sarà in corsivo se <userinput
>italic</userinput
> è <emphasis
>true</emphasis
>.</para>
<para
>Il testo sarà in grassetto se <userinput
>bold</userinput
> è <emphasis
>true</emphasis
>.</para>
<para
>Il testo sarà sottolineato se <userinput
>underline</userinput
> è <emphasis
>true</emphasis
>.</para>
<para
>Il testo sarà in barrato se <userinput
>strikeout</userinput
> è <emphasis
>true</emphasis
>.</para>
<para
>Il testo sarà controllato ortograficamente se <userinput
>spellChecking</userinput
> è <emphasis
>true</emphasis
>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>L'elemento <userinput
>keywords</userinput
> del gruppo <userinput
>general</userinput
> definisce le proprietà delle parole chiave. Gli attributi disponibili sono:</term>

<listitem>
<para
><userinput
>casesensitive</userinput
> può essere <emphasis
>true</emphasis
> oppure <emphasis
>false</emphasis
>; se è <emphasis
>true</emphasis
> tutte le parole chiave soddisfano la sensibilità alle maiuscole.</para>
<para
><userinput
>weakDeliminator</userinput
> è una lista di caratteri che non agiscono da delimitatori di parole; per esempio, il punto <userinput
>«.»</userinput
> è un delimitatore di parola. Se assumiamo che una parola chiave in una <userinput
>lista</userinput
> possa contenere un punto, sarà soddisfatta solo se specifichi che il punto è un delimitatore debole.</para>
<para
><userinput
>additionalDeliminator</userinput
> definisce delimitatori addizionali.</para>
<para
><userinput
>wordWrapDeliminator</userinput
> definisce i caratteri dopo dei quali una riga può andare a capo.</para>
<para
>Sono delimitatori predefiniti e terminatori di parola i caratteri <userinput
>.():!+,-&lt;=&gt;%&amp;*/;?[]^{|}~\</userinput
>, gli spazi (<userinput
>« »</userinput
>) e i tabulatori (<userinput
>«\t»</userinput
>).</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>L'elemento <userinput
>comment</userinput
> del gruppo <userinput
>comments</userinput
> definisce le proprietà che sono usate in <menuchoice
><guimenu
>Strumenti</guimenu
><guimenuitem
>Commenta</guimenuitem
></menuchoice
> e <menuchoice
><guimenu
>Strumenti</guimenu
><guimenuitem
>Decommenta</guimenuitem
></menuchoice
>. Gli attributi disponibili sono:</term>

<listitem>
<para
><userinput
>name</userinput
> è sia <emphasis
>singleLine</emphasis
> che <emphasis
>multiLine</emphasis
>. Se scegli <emphasis
>multiLine</emphasis
> sono richiesti gli attributi <emphasis
>end</emphasis
> e <emphasis
>region</emphasis
>.</para>
<para
><userinput
>start</userinput
> definisce la stringa usata per iniziare un commento. In C++ sarebbe &quot;/*&quot;.</para>
<para
><userinput
>end</userinput
> definisce la stringa per chiudere un commento. In C++ questo sarebbe &quot;*/&quot;.</para>
<para
><userinput
>region</userinput
> dovrebbe essere il nome dei commenti multi-riga raggruppabili. Assumendo di avere nelle regole <emphasis
>beginRegion="Comment"</emphasis
> ... <emphasis
>endRegion="Comment"</emphasis
> si dovrebbe usare <emphasis
>region="Comment"</emphasis
>. In questo modo l'azione di decommento funziona anche se non viene selezionato tutto il testo di un commento multi-riga, il cursore deve solo essere all'interno del commento.</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>L'elemento <userinput
>raggruppamento</userinput
> del gruppo <userinput
>general</userinput
> definisce le proprietà di raggruppamento del codice. Gli attributi disponibili sono:</term>

<listitem>
<para
>Se <userinput
>indentationsensitive</userinput
> è <emphasis
>true</emphasis
> i marcatori del raggruppamento del codice saranno aggiunti basandosi sul rientro, come nel linguaggio di scripting Python. Di solito non hai necessità di impostarlo, e di solito è impostato a <emphasis
>false</emphasis
>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>L'elemento <userinput
>indentation</userinput
>del gruppo <userinput
>general</userinput
> definisce quali rientratori verranno usati. Raccomandiamo caldamente però di omettere questo elemento, dato che il rientratore sarà impostato sia definendo un tipo di file, sia aggiungendo un modello di riga al file di testo. Se si specifica un rientratore, infatti, si forzerà l'uso un rientro specifico, che potrebbe non andar bene sempre. Gli attributi disponibili sono:</term>

<listitem>
<para
><userinput
>modo</userinput
> è il nome del rientratore. I rientratori disponibili sono: <emphasis
>normal, cstyle, haskell, lilypond, lisp, python, ruby</emphasis
> e <emphasis
>xml</emphasis
>.</para>
</listitem>
</varlistentry>


</variablelist>


</sect3>

<sect3 id="kate-highlight-default-styles">
<title
>Stili predefiniti disponibili</title>
<para
>Gli stili predefiniti sono stati <link linkend="kate-highlight-system-default-styles"
>già trattati</link
>, come piccolo riassunto: gli stili predefiniti sono i caratteri predefiniti e gli stili colore.</para>
<variablelist>
<varlistentry>
<term
>Stili generali predefiniti:</term>
<listitem>
<para
><userinput
>dsNormal</userinput
>, quando non è richiesta nessuna evidenziazione speciale.</para>
<para
><userinput
>dsKeyword</userinput
>, parola chiave integrata nel linguaggio.</para>
<para
><userinput
>dsFunction</userinput
>, chiamate di funzioni e definizioni.</para>
<para
><userinput
>dsVariabile</userinput
>, se applicabile: nomi delle variabili (ad es. $someVar in PHP/Perl).</para>
<para
><userinput
>dsControlFlow</userinput
>, parole chiave per il controllo del flusso, come if, else, switch, break, return, yield, ...</para>
<para
><userinput
>dsOperator</userinput
>, operatori come + - * / :: &lt; &gt;</para>
<para
><userinput
>dsBuiltIn</userinput
>, funzioni integrate, classi e oggetti.</para>
<para
><userinput
>dsExtension</userinput
>, estensioni comuni, come le classi Qt e le funzioni o le macro in C++ e in Python.</para>
<para
><userinput
>dsPreprocessor</userinput
>, direttive al preprocessore o definizioni di macro.</para>
<para
><userinput
>dsAttribute</userinput
>, annotazioni come @override e __declspec(...).</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Stili predefiniti relativi alle stringhe:</term>
<listitem>
<para
><userinput
>dsChar</userinput
>, caratteri singoli, come 'x'.</para>
<para
><userinput
>dsSpecialChar</userinput
>, caratteri con significati speciali nelle stringhe, come escape, sostituzioni, oppure operatori regex.</para>
<para
><userinput
>dsString</userinput
>, stringhe come "hello world".</para>
<para
><userinput
>dsVerbatimString</userinput
>, letterale o stringa grezza, come 'raw \backlash' in Perl, CoffeeScript, e shell, come r'\raw' in Python.</para>
<para
><userinput
>dsSpecialString</userinput
>, SQL, regexes, documenti HERE, modi LaTeX math, ...</para>
<para
><userinput
>dsImport</userinput
>, importazione, inclusione, richieste di moduli.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Stili predefiniti relativi ai numeri:</term>
<listitem>
<para
><userinput
>dsDataType</userinput
>, tipi di dati integrati, come int, void, u64.</para>
<para
><userinput
>dsDecVal</userinput
>, valori decimali.</para>
<para
><userinput
>dsBaseN</userinput
>, valori con base diversa da 10.</para>
<para
><userinput
>dsFloat</userinput
>, valori in virgola mobile.</para>
<para
><userinput
>dsCostant</userinput
>, costanti integrate e definite dall'utente, come PI.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Commenti e stili predefiniti relativi alla documentazione:</term>
<listitem>
<para
><userinput
>dsComment</userinput
>, commenti.</para>
<para
><userinput
>dsDocumentation</userinput
>, /** Commenti nella documentazione */ o """docstrings""".</para>
<para
><userinput
>dsAnnotation</userinput
>, comandi nella documentazione, come @param, @brief.</para>
<para
><userinput
>dsCommentVar</userinput
>, i nomi delle variabili usati nei comandi precedenti, come "pippobar" in @param pippobar.</para>
<para
><userinput
>dsRegionMarker</userinput
>, delimitatori di regioni, come //BEGIN e //END nei commenti.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Altri stili predefiniti:</term>
<listitem>
<para
><userinput
>dsInformation</userinput
>, annotazioni e suggerimenti, come @note in doxygen.</para>
<para
><userinput
>dsWarning</userinput
>, avvisi, come @warning in doxygen.</para>
<para
><userinput
>dsAlert</userinput
>, parole speciali, come TODO, FIXME, XXXX.</para>
<para
><userinput
>dsError</userinput
>, evidenziazione di errori e sintassi errata.</para>
<para
><userinput
>dsOthers</userinput
> per tutto il resto.</para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2 id="kate-highlight-rules-detailled">
<title
>Regole di rilevamento dell'evidenziazione</title>

<para
>Questa sezione descrive le regole di rilevamento della sintassi.</para>

<para
>Ogni regola può associare zero o più caratteri all'inizio della stringa su cui è testata. Se la regola corrisponde i caratteri associati sono assegnati allo stile o all'<emphasis
>attributo</emphasis
> definito dalla regola; una regola può chiedere che l'attuale contesto venga cambiato.</para>

<para
>Una regola è un qualcosa che assomiglia a questo:</para>

<programlisting
>&lt;RuleName attribute=&quot;(identifier)&quot; context=&quot;(identifier)&quot; [attributi specifici della regola] /&gt;</programlisting>

<para
><emphasis
>attribute</emphasis
> identifica lo stile da usare per i caratteri associati secondo il nome, mentre <emphasis
>context</emphasis
> identifica il contesto da usare da qui in avanti.</para>

<para
><emphasis
>context</emphasis
> può essere identificato da:</para>

<itemizedlist>
<listitem>
<para
><emphasis
>identifier</emphasis
>, che è il nome dell'altro contesto.</para>
</listitem>
<listitem>
<para
><emphasis
>order</emphasis
>, che dice al motore di rimanere nel contesto attuale (<userinput
>#stay</userinput
>), oppure di ritornare a quello precedentemente usato nella stringa (<userinput
>#pop</userinput
>).</para>
<para
>Per tornare indietro di più passi la parola chiave #pop può essere ripetuta: <userinput
>#pop#pop#pop</userinput
></para>
</listitem>
<listitem>
<para
><emphasis
>order</emphasis
> seguito da un punto esclamativo (<emphasis
>!</emphasis
>) e <emphasis
>identifier</emphasis
>, che faranno prima seguire al motore l'ordine, e poi lo mandano in un altro contesto, ad esempio <userinput
>#pop#pop!OtherContext</userinput
>.</para>
</listitem>
</itemizedlist>

<para
>Alcune regole possono avere delle <emphasis
>regole figlie</emphasis
>, che vengono valutate solo se la regola genitore corrisponde. All'intera stringa corrispondente sarà dato l'attributo definito dalla regola genitore. Una regola con delle regole figlie assomiglia a questo:</para>

<programlisting
>&lt;RuleName (attributi)&gt;
  &lt;ChildRuleName (attributi) /&gt;
  ...
&lt;/RuleName&gt;
</programlisting>


<para
>Gli attributi specifici per la regola variano, e sono descritti nelle sezioni seguenti.</para>


<itemizedlist>
<title
>Attributi comuni</title>
<para
>Tutte le regole hanno in comune i seguenti attributi, e sono disponibili ogni volta che compare <userinput
>(attributi comuni)</userinput
>. Sono attributi richiesti <emphasis
>attribute</emphasis
> e <emphasis
>context</emphasis
>, tutti gli altri sono opzionali. </para>

<listitem>
<para
><emphasis
>attribute</emphasis
>: un attributo associato ad un determinato <emphasis
>itemData</emphasis
>.</para>
</listitem>
<listitem>
<para
><emphasis
>context</emphasis
>: specifica il contesto al quale il sistema di evidenziazione passa se la regola corrisponde.</para>
</listitem>
<listitem>
<para
><emphasis
>beginRegion</emphasis
>: inizia un blocco di raggruppamento del codice. Predefinito: non impostato.</para>
</listitem>
<listitem>
<para
><emphasis
>endRegion</emphasis
>: chiude un un blocco di raggruppamento del codice. Predefinito: non impostato.</para>
</listitem>
<listitem>
<para
><emphasis
>lookAhead</emphasis
>: se impostato a <emphasis
>true</emphasis
> il sistema di evidenziazione non processerà la lunghezza assegnata. Predefinito: <emphasis
>false</emphasis
>.</para>
</listitem>
<listitem>
<para
><emphasis
>firstNonSpace</emphasis
>: corrisponde solo se la stringa è la prima senza spazi nella riga. Predefinito: <emphasis
>false</emphasis
>.</para>
</listitem>
<listitem>
<para
><emphasis
>column</emphasis
>: corrisponde solo se la colonna combacia. Predefinito: non impostato.</para>
</listitem>
</itemizedlist>

<itemizedlist>
<title
>Regole dinamiche</title>
<para
>Alcune regole permettono di usare l'attributo opzionale <userinput
>dynamic</userinput
> di tipo booleano il cui valore predefinito è <emphasis
>false</emphasis
>. Se dynamic è <emphasis
>true</emphasis
>, una regola può usare un segnaposto che rappresenta le corrispondenze di una regola di tipo <emphasis
>espressione regolare</emphasis
> che è passata al contesto corretto nei proprio attributi <userinput
>string</userinput
> o <userinput
>char</userinput
>. Nel caso di <userinput
>string</userinput
> il segnaposto <replaceable
>%N</replaceable
> (dove N è un numero) sarà sostituito con la corrispondente stringa di cattura <replaceable
>N</replaceable
> dall'espressione regolare chiamante. Nel caso di <userinput
>char</userinput
> il segnaposto deve essere un numero <replaceable
>N</replaceable
> e sarà sostituito con il primo carattere della corrispondente stringa di cattura <replaceable
>N</replaceable
> dall'espressione regolare chiamante. Quando una regola permette l'uso di questo attributo conterrà <emphasis
>(dynamic)</emphasis
>.</para>

<listitem>
<para
><emphasis
>dynamic</emphasis
>: può essere <emphasis
>(true|false)</emphasis
>.</para>
</listitem>
</itemizedlist>

<sect3 id="highlighting-rules-in-detail">
<title
>Le regole in dettaglio</title>

<variablelist>
<varlistentry>
<term
>DetectChar</term>
<listitem>
<para
>Rileva un singolo carattere specifico. Usato comunemente per trovare ad esempio la fine di una stringa tra virgolette.</para>
<programlisting
>&lt;DetectChar char=&quot;(carattere)&quot; (attributi comuni) (dynamic) /&gt;</programlisting>
<para
>L'attributo <userinput
>char</userinput
> definisce il carattere da abbinare.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Detect2Chars</term>
<listitem>
<para
>Rileva due caratteri specifici in un ordine definito.</para>
<programlisting
>&lt;Detect2Chars char=&quot;(carattere)&quot; char1=&quot;(carattere)&quot; (attributi comuni) (dynamic) /&gt;</programlisting>
<para
>L'attributo <userinput
>char</userinput
> definisce il primo carattere da associare, <userinput
>char1</userinput
> il secondo.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>AnyChar</term>
<listitem>
<para
>Rileva un carattere da un insieme di caratteri specificati.</para>
<programlisting
>&lt;AnyChar String=&quot;(stringa)&quot; (attributi comuni) /&gt;</programlisting>
<para
>L'attributo <userinput
>String</userinput
> definisce l'insieme dei caratteri.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>StringDetect</term>
<listitem>
<para
>Rileva una stringa esatta.</para>
<programlisting
>&lt;StringDetect String=&quot;(stringa)&quot; [insensitive=&quot;true|false&quot;] (attributi comuni) (dynamic) /&gt;</programlisting>
<para
>L'attributo <userinput
>String</userinput
> definisce la stringa da abbinare. All'attributo <userinput
>insensitive</userinput
> viene assegnato come valore predefinito <emphasis
>false</emphasis
>, e viene passato alla funzione di confronto della stringa. Se il valore è <emphasis
>true</emphasis
> allora nel confronto non si terrebbe conto delle maiuscole.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>WordDetect</term>
<listitem>
<para
>Non rileva una stringa esatta, ma i confini di una parola quali un punto <userinput
>'.'</userinput
> o uno spazio all'inizio o alla fine della parola. Pensa <userinput
>\b&lt;string&gt;\b</userinput
> come un'espressione regolare, ma più veloce della regola <userinput
>RegExpr</userinput
>.</para>
<programlisting
>&lt;WordDetect String=&quot;(stringa)&quot; [insensitive=&quot;true|false&quot;] (attributi comuni) (dynamic) /&gt;</programlisting>
<para
>L'attributo <userinput
>String</userinput
> definisce la stringa da abbinare. All'attributo <userinput
>insensitive</userinput
> viene assegnato come valore predefinito <emphasis
>false</emphasis
>, e viene passato alla funzione di confronto della stringa. Se il valore è <emphasis
>true</emphasis
> allora nel confronto non si terrebbe conto delle maiuscole.</para>
<para
>Da: Kate 3.5 (KDE 4.5)</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>RegExpr</term>
<listitem>
<para
>Corrisponde con un'espressione regolare.</para>
<programlisting
>&lt;RegExpr String=&quot;(stringa)&quot; [insensitive=&quot;true|false&quot;] [minimal=&quot;true|false&quot;] (attributi comuni) (dynamic) /&gt;</programlisting>
<para
>L'attributo <userinput
>String</userinput
> definisce l'espressione regolare.</para>
<para
><userinput
>insensitive</userinput
> ha come valore predefinito <emphasis
>false</emphasis
>, e viene passato al motore per le espressioni regolari.</para>
<para
><userinput
>minimal</userinput
> ha come valore predefinito <emphasis
>false</emphasis
>, e viene passato al motore per le espressioni regolari.</para>
<para
>Le regole sono sempre confrontate con l'inizio della stringa corrente, tuttavia un'espressione regolare iniziante con un apice (<literal
>^</literal
>) è segno che la regola dovrebbe essere confrontata invece con l'inizio di una riga.</para>
<para
>Vedi <link linkend="regular-expressions"
>Espressioni regolari</link
> per maggiori informazioni.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>keyword</term>
<listitem>
<para
>Rileva una parola chiava da una lista specifica.</para>
<programlisting
>&lt;keyword String=&quot;(nome lista)&quot; (attributi comuni) /&gt;</programlisting>
<para
>L'attributo <userinput
>String</userinput
> identifica la lista di parole chiave per nome. Deve esistere una lista con questo nome.</para>
<para
>Il sistema di evidenziazione elabora regole di parole chiave in maniera molto ottimizzata. Questo rende assolutamente necessario che ogni parola chiave da confrontare sia circondata da delimitatori definiti, sia impliciti (i delimitatori predefiniti) che espliciti, specificati dalla proprietà <emphasis
>additionalDeliminator</emphasis
> con l'etichetta <emphasis
>keywords</emphasis
>.</para>
<para
>Se una parola chiave da confrontare dovesse contenere un carattere di delimitazione, allora questo dovrebbe essere aggiunto alla proprietà <emphasis
>weakDeliminator</emphasis
> con l'etichetta <emphasis
>keywords</emphasis
>. Questo carattere perderebbe le sue proprietà di delimitatore in tutte le regole <emphasis
>keywords</emphasis
>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>Int</term>
<listitem>
<para
>Rileva un numero intero.</para>
<para
><programlisting
>&lt;Int (attributi comuni) (dynamic) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici. Le regole figlie sono usate tipicamente per individuare combinazioni di <userinput
>L</userinput
> e <userinput
>U</userinput
> dopo il numero che sta ad indicare il tipo di intero nel codice programma. Al momento tutte le regole sono consentite come regole figlie, però la <acronym
>DTD</acronym
> permette solo la regola figlia <userinput
>StringDetect</userinput
>.</para>
<para
>L'esempio seguente associa numeri interi seguiti dal carattere «L». <programlisting
>&lt;Int attribute="Decimal" context="#stay" &gt;
  &lt;StringDetect attribute="Decimal" context="#stay" String="L" insensitive="true"/&gt;
&lt;/Int&gt;
</programlisting
></para>

</listitem>
</varlistentry>

<varlistentry>
<term
>Float</term>
<listitem>
<para
>Rileva un numero in virgola mobile.</para>
<para
><programlisting
>&lt;Float (attributi comuni) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici. <userinput
>AnyChar</userinput
> è permesso come regola figlia e tipicamente usato per rilevare combinazioni, vedi come riferimento la regola <userinput
>Int</userinput
>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>HlCOct</term>
<listitem>
<para
>Rileva un numero con rappresentazione ottale.</para>
<para
><programlisting
>&lt;HlCOct (attributi comuni) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>HlCHex</term>
<listitem>
<para
>Rileva un numero con rappresentazione esadecimale.</para>
<para
><programlisting
>&lt;HlCHex (attributi comuni) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>HlCStringChar</term>
<listitem>
<para
>Rileva un carattere di escape.</para>
<para
><programlisting
>&lt;HlCStringChar (attributi comuni) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici.</para>

<para
>Controlla la corrispondenza di espressioni letterali di caratteri generalmente usate nel codice dei programmi, per esempio <userinput
>\n</userinput
> (nuova riga) o <userinput
>\t</userinput
> (TAB).</para>

<para
>I seguenti caratteri corrisponderanno se saranno seguiti da una barra inversa (<literal
>\</literal
>): <userinput
>abefnrtv&quot;'?\</userinput
>. Inoltre corrisponderanno numeri esadecimali preceduti dal carattere di escape, come per esempio <userinput
>\xff</userinput
> e numeri ottali preceduti dal carattere di escape, per esempio <userinput
>\033</userinput
>.</para>

</listitem>
</varlistentry>

<varlistentry>
<term
>HlCChar</term>
<listitem>
<para
>Rileva il carattere C</para>
<para
><programlisting
>&lt;HlCChar (attributi comuni) /&gt;</programlisting
></para>
<para
>Questa regola non ha attributi specifici.</para>

<para
>Controlla la corrispondenza di caratteri C racchiusi da un accento (Esempio: <userinput
>'c'</userinput
>). Gli accenti possono essere caratteri singoli o caratteri di escape. Vedi HlCStringChar per le sequenze di caratteri di escape associate.</para>

</listitem>
</varlistentry>

<varlistentry>
<term
>RangeDetect</term>
<listitem>
<para
>Rileva una stringa con caratteri di inizio e di fine definiti.</para>
<programlisting
>&lt;RangeDetect char=&quot;(carattere)&quot;  char1=&quot;(carattere)&quot; (attributi comuni) /&gt;</programlisting>
<para
><userinput
>char</userinput
> definisce il carattere con cui inizia l'intervallo, <userinput
>char1</userinput
> il carattere con cui finisce.</para>
<para
>Utile per individuare per esempio piccole stringhe tra virgolette e simili; nota però che non verranno in questo modo trovate le stringhe che si estendono dopo un'interruzione di riga. Questo perché il motore di evidenziazione lavora su una riga alla volta.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>LineContinue</term>
<listitem>
<para
>Associa un carattere specificato con la fine di una riga.</para>
<programlisting
>&lt;LineContinue (attributi comuni) [char="\"] /&gt;</programlisting>
<para
><userinput
>char</userinput
> carattere opzionale da associare; come predefinito c'è la barra inversa (<userinput
>'\'</userinput
>). Novità da KDE 4.13.</para>
<para
>Questa regola è utile per cambiare il contesto alla fine di una riga. È necessaria per esempio in C/C++, per continuare le macro o le stringhe.</para>
</listitem>
</varlistentry>

<varlistentry>
<term
>IncludeRules</term>
<listitem>
<para
>Include delle regole da un altro file di contesto o da un linguaggio.</para>
<programlisting
>&lt;IncludeRules context=&quot;contextlink&quot; [includeAttrib=&quot;true|false&quot;] /&gt;</programlisting>

<para
>L'attributo <userinput
>context</userinput
> definisce quale contesto includere.</para>
<para
>Se è una stringa semplice include tutte le regole nel contesto corrente, per esempio: <programlisting
>&lt;IncludeRules context=&quot;altroContesto&quot; /&gt;</programlisting
></para>

<para
>Se la stringa contiene <userinput
>##</userinput
> il sistema di evidenziazione cercherà un contesto in un altra definizione di linguaggio con il nome assegnato, per esempio <programlisting
>&lt;IncludeRules context=&quot;String##C++&quot; /&gt;</programlisting
> dovrebbe includere il contesto <emphasis
>String</emphasis
> dalle definizioni di evidenziazione del <emphasis
>C++</emphasis
>.</para>
<para
>Se l'attributo <userinput
>includeAttrib</userinput
> è <emphasis
>true</emphasis
> cambia l'attributo di destinazione con uno del sorgente. Questo è richiesto per esempio per fare dei commenti, se il testo associato al contesto incluso ha una diversa evidenziazione dal contesto che lo ospita. </para>
</listitem>
</varlistentry>


<varlistentry>
<term
>DetectSpaces</term>
<listitem>
<para
>Rileva gli spazi.</para>
<programlisting
>&lt;DetectSpaces (attributi comuni) /&gt;</programlisting>

<para
>Questa regola non ha attributi specifici.</para>
<para
>Usa questa regola quando sai che potrai incontrare numerosi spazi, per esempio all'inizio di righe rientrate. Questa regola salterà tutti gli spazi in un colpo solo, invece di provare regole multiple da scartarle di volta in volta per mancanza di corrispondenza.</para>
</listitem>
</varlistentry>


<varlistentry>
<term
>DetectIdentifier</term>
<listitem>
<para
>Rileva gli identificatori di stringhe (come un'espressione regolare [a-zA-Z_][a-zA-Z0-9_]*).</para>
<programlisting
>&lt;DetectIdentifier (attributi comuni) /&gt;</programlisting>

<para
>Questa regola non ha attributi specifici.</para>
<para
>Usa questa regola per saltare subito una stringa di caratteri alfanumerici, invece di usare più regole e saltare i caratteri uno alla volta per mancanza di corrispondenza.</para>
</listitem>
</varlistentry>

</variablelist>
</sect3>

<sect3>
<title
>Suggerimenti e trucchi</title>

<itemizedlist>
<para
>Una volta che hai capito come funziona il passaggio del contesto sarà semplice scrivere definizioni di evidenziazione, anche se dovresti controllare attentamente quale regola scegliere e in quale situazione. Le espressioni regolari sono molto potenti, ma sono lente se comparate con altre regole. Così tieni conto dei suggerimenti seguenti. </para>

<listitem>
<para
>Se cerchi la corrispondenza di solo due caratteri usa <userinput
>Detect2Chars</userinput
> invece che <userinput
>StringDetect</userinput
>. Lo stesso vale per <userinput
>DetectChar</userinput
>.</para>
</listitem>
<listitem>
<para
>Le espressioni regolari sono semplici da usare, ma spesso c'è un altro modo molto più veloce per ottenere gli stessi risultati. Considera di voler semplicemente cercare la corrispondenza del carattere <userinput
>«#»</userinput
> solo quando è il primo della riga. Una soluzione basata su un'espressione regolare assomiglierebbe a questo: <programlisting
>&lt;RegExpr attribute=&quot;Macro&quot; context=&quot;macro&quot; String=&quot;^\s*#&quot; /&gt;</programlisting
>. Puoi ottenere lo stesso risultato in maniera più veloce usando: <programlisting
>&lt;DetectChar attribute=&quot;Macro&quot; context=&quot;macro&quot; char=&quot;#&quot; firstNonSpace=&quot;true&quot; /&gt;</programlisting
>. Se vuoi cercare corrispondenze per l'espressione regolare <userinput
>'^#'</userinput
> puoi sempre usare <userinput
>DetectChar</userinput
> con l'attributo <userinput
>column=&quot;0&quot;</userinput
>. L'attributo <userinput
>column</userinput
> conta i caratteri, e un tabulatore è un solo carattere. </para>
</listitem>
<listitem>
<para
>Puoi cambiare i contesti senza bisogno di elaborare dei caratteri. Se vuoi cambiare contesto quando incontri la stringa <userinput
>*/</userinput
> devi almeno elaborare quella stringa nel contesto del testo. La regola qui sotto corrisponderà, e l'attributo <userinput
>lookAhead</userinput
> farà in modo che l'evidenziatore tenga la stringa corrispondente per il contesto successivo. <programlisting
>&lt;Detect2Chars attribute=&quot;Comment&quot; context=&quot;#pop&quot; char=&quot;*&quot; char1=&quot;/&quot; lookAhead=&quot;true&quot; /&gt;</programlisting>
</para>
</listitem>
<listitem>
<para
>Usa <userinput
>DetectSpaces</userinput
> se sai di incontrare molti spazi.</para>
</listitem>
<listitem>
<para
>Usa <userinput
>DetectIdentifier</userinput
> al posto dell'espressione regolare <userinput
>'[a-zA-Z_]\w*'</userinput
>.</para>
</listitem>
<listitem>
<para
>Usa gli stili predefiniti ogni volta che puoi. In questo modo l'utente si troverà in un ambiente familiare.</para>
</listitem>
<listitem>
<para
>Guarda dentro altri file XML, per vedere come le altre persone implementano le regole difficili.</para>
</listitem>
<listitem>
<para
>Puoi validare ogni file XML usando il comando <command
>validatehl.sh language.xsd mySyntax.xml</command
>. I file <filename
>validatehl.sh</filename
> e <filename
>language.xsd</filename
> si trovano nel <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema"
>deposito di evidenziazione della sintassi</ulink
>. </para>
</listitem>
<listitem>
<para
>Se ripeti molto spesso delle espressioni regolari complesse puoi usare <emphasis
>ENTITIES</emphasis
>. Esempio:</para>
<programlisting
>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE language SYSTEM "language.dtd"
[
        &lt;!ENTITY myref    "[A-Za-z_:][\w.:_-]*"&gt;
]&gt;
</programlisting>
<para
>Ora puoi usare <emphasis
>&amp;myref;</emphasis
> invece dell'espressione regolare.</para>
</listitem>
</itemizedlist>
</sect3>

</sect2>

</sect1>


<sect1 id="dev-scripting">
<title
>Scripting con JavaScript</title>

<para
>Il componente editor di &kappname; è facilmente estendibile attraverso degli script. Il linguaggio di script è ECMAScript (comunemente noto come JavaScript). &kappname; supporta due tipi di script: script di rientro e a riga di comando. </para>

<sect2 id="dev-scripting-indentation">
<title
>Script di rientro</title>

<para
>Gli script di rientro, noti anche come rientratori, fanno rientrare automaticamente il codice sorgente mentre si scrive. Per esempio, spesso il livello di rientro aumenta dopo aver premuto Invio. </para>

<para
>Le sezioni seguenti descrivono passo-passo come creare la struttura di un semplice rientratore. Come primo passo crea un nuovo file <filename
>*.js</filename
> chiamato &eg; <filename
>javascript.js</filename
> nella cartella home locale <filename
>$<envar
>XDG_DATA_HOME</envar
>/katepart5/script/indentation</filename
>. Al suo interno la variabile di ambiente <envar
>XDG_DATA_HOME</envar
> viene tipicamente espansa sia in <filename
>~/.local</filename
> che in <filename
>~/.local/share</filename
>. </para>
<para
>In &Windows; questi file si trovano in <filename
>%USER%\AppData\Local\katepart5\indentation</filename
>. <replaceable
>%USERPROFILE%</replaceable
> viene generalmente espanso in <filename
>C:\\Users\\<replaceable
>utente</replaceable
></filename
>.</para>

<sect3 id="dev-scripting-indentation-header">
<title
>L'intestazione dello script di rientro</title>
<para
>L'intestazione del file <filename
>javascript.js</filename
> è incorporata come JSON all'inizio del documento, e ha la forma seguente: <programlisting>
var katescript = {
    "name": "JavaScript",
    "author": "Pippo &lt;pippo@topolinia.it&gt;"
    "license": "BSD License",
    "revision": 1,
    "kate-version": "5.1",
    "required-syntax-style":"javascript",
    "indent-languages": ["javascript"],
    "priority": 0,
}; // kate-script-header, deve essere all'inizio della riga senza commenti
</programlisting
> Ogni voce viene ora spiegata in dettaglio: <itemizedlist>
<listitem
><para
><literal
>name</literal
> [obbligatorio]: questo è il nome del rientratore che appare nel menu <menuchoice
><guimenu
>Strumenti</guimenu
><guimenuitem
>Rientro</guimenuitem
></menuchoice
> e nella finestra di configurazione. </para
></listitem>
<listitem
><para
><literal
>author</literal
> [facoltativo]: il nome dell'autore e informazioni per contattarlo. </para
></listitem>
<listitem
><para
><literal
>license</literal
> [facoltativo]: forma breve della licenza, come Licenza BSD o LGPLv3. </para
></listitem>
<listitem
><para
><literal
>revision</literal
> [obbligatorio]: la revisione dello script. Questo numero va aumentato ad ogni sua modifica. </para
></listitem>
<listitem
><para
><literal
>kate-version</literal
> [obbligatorio]: versione minima di &kappname; richiesta. </para
></listitem>
<listitem
><para
><literal
>required-syntax-style</literal
> [facoltativo]: lo stile della sintassi richiesto, se soddisfa lo <literal
>stile</literal
> specificato nei file di evidenziazione della sintassi. È importante per i rientratori che richiedono informazioni di evidenziazione specifiche nel documento. Se uno stile di sintassi richiesto viene specificato, il rientratore è disponibile solo quando è attivo l'evidenziatore appropriato. Ciò impedisce il <quote
>comportamento non definito</quote
> causato dall'uso del rientratore senza lo schema di evidenziazione atteso. Per esempio, il rientratore di Ruby lo usa nei file <filename
>ruby.js</filename
> e <filename
>ruby.xml</filename
>. </para
></listitem>
<listitem
><para
><literal
>indent-languages</literal
> [facoltativo]: elenco JSON di stili di sintassi che il rientratore può far rientrare correttamente, &eg;: <literal
>["c++", "java"]</literal
>. </para
></listitem>
<listitem
><para
><literal
>priority</literal
> [facoltativo]: se ci sono più rientratori che si adattano a un certo file evidenziato la priorità decide quale viene scelto come predefinito. </para
></listitem>
</itemizedlist>
</para>

</sect3>

<sect3 id="dev-scripting-indentation-body">
<title
>Il codice sorgente del rientratore</title>
<para
>Dopo aver specificato l'intestazione, questa sezione spiega come funziona lo script di rientro vero e proprio. La struttura fondamentale ha questo aspetto: <programlisting>
// librerie katepart js necessarie, per esempio range.js se usi Range
require ("range.js");
  
triggerCharacters = "{}/:;";
function indent(riga, larghezza_rientro, carattere)
{
    // richiamato a ogni ritorno a capo (<varname
>carattere</varname
> == '\n') e per tutti i caratteri
    // specificati nella in variabile globale triggerCharacters. Quando si chiama
    // <menuchoice
><guimenu
>Strumenti</guimenu
><guimenuitem
>Allinea</guimenuitem
></menuchoice
>, la variabile <varname
>carattere</varname
> è vuota, cioè <varname
>caratteri</varname
> == ''.
    //
    // Vedi anche: API di scripting
    return -2;
}
</programlisting
> La funzione <function
>indent()</function
> ha tre argomenti:<itemizedlist
><listitem
><para
><literal
>riga</literal
>: la riga da far rientrare;</para
></listitem
> <listitem
><para
><literal
>larghezza_rientro</literal
>: la larghezza del rientro espressa come numero di spazi;</para
></listitem
> <listitem
><para
><literal
>carattere</literal
>: un carattere di ritorno a capo (<varname
>carattere</varname
> == '\n'), un carattere di attivazione specificato in <varname
>triggerCharacters</varname
>, o vuota se l'utente ha attivato l'azione <menuchoice
><guimenu
>Strumenti</guimenu
><guimenuitem
>Allinea</guimenuitem
></menuchoice
>.</para
></listitem
> </itemizedlist
> Il valore restituito dalla funzione <function
>indent()</function
> specifica come far rientrare la riga. Se il valore è un semplice numero intero, viene interpretato come segue: <itemizedlist
> <listitem
><para
>Valore restituito <returnvalue
>-2</returnvalue
>: non fare nulla;</para
></listitem
><listitem
><para
>Valore restituito <returnvalue
>-1</returnvalue
>: mantieni il rientro (cerca una riga non vuota precedente)</para
></listitem
><listitem
><para
>Valore restituito <returnvalue
>0</returnvalue
>: I numeri numbers ≥ 0 specificano il rientro in spazi</para
></listitem
></itemizedlist
>In alternativa, si può restituire un array di due elementi: <itemizedlist
><listitem
><para
><userinput
>return <returnvalue
>[ indent, align ]</returnvalue
>;</userinput
></para
></listitem
></itemizedlist
> In questo caso, il primo elemento è il rientro, con lo stesso significato di cui sopra. Il secondo elemento, invece, è un valore assoluto che rappresenta una colonna di <quote
>allineamento</quote
>. Se questo valore è maggiore del valore di rientro, la differenza rappresenta un numero di spazi da aggiungere dopo il rientro della prima variabile. Altrimenti, il secondo numero viene ignorato. Usare sia tabulatori che spazi per il rientro viene spesso indicato come <quote
>modalità mista</quote
>. </para>

<para
>Considera il seguente esempio: supponiamo di usare le tabulazioni per il rientro, e la loro ampiezza è impostata a 4. Qui, &lt;tab&gt; indica una tabulazione e «.» uno spazio: <programlisting>
1: &lt;tab&gt;&lt;tab&gt;pippo("ciao",
2: &lt;tab&gt;&lt;tab&gt;......"mondo");
</programlisting
> Quando si allinea la seconda riga, la funzione <function
>indent()</function
> restituisce <returnvalue
>[8, 15]</returnvalue
>. Perciò, si inseriscono due tabulazioni per far rientrare fino alla colonna 8, e vengono aggiunti sette spazi per allineare il secondo argomento al primo, in modo che rimanga allineato se il file viene visualizzato con un'ampiezza di tabulazione diversa. </para>

<para
>Un'installazione predefinita di &kde; include &kappname; con diversi rientratori. Il codice JavaScript corrispondente si può trovare in <filename
>$<envar
>XDG_DATA_DIRS</envar
>/katepart5/script/indentation</filename
>.</para>
<para
>In &Windows; questi file si trovano in <filename
>%USER%\AppData\Local\katepart5\indentation</filename
>. <replaceable
>%USER%</replaceable
> viene generalmente espanso in <filename
>C:\\Users\\<replaceable
>utente</replaceable
></filename
>. </para>

<para
>Lo sviluppo di un rientratore richiede il ricaricamento gli script, per testare le modifiche. Invece di riavviare l'applicazione puoi però passare alla riga di comando, e digitare il comando <command
>reload-scripts</command
>. </para>

<para
>Se sviluppi degli script utili, per piacere considera la possibilità di contribuirli al progetto &kappname; <ulink url="mailto:kwrite-devel@kde.org"
>contattando la lista di distribuzione</ulink
>. </para>

</sect3>
</sect2>

<sect2 id="dev-scripting-command-line">
<title
>Script da riga di comando</title>

<para
>Essendo difficile soddisfare le necessità di tutti, &kappname; supporta dei piccoli strumenti di supporto per manipolare velocemente il testo attraverso la <link linkend="advanced-editing-tools-commandline"
>riga di comando integrata</link
>. Per esempio, il comando <command
>sort</command
> è implementato come uno script. Questa sezione spiega come creare file <literal role="extension"
>*.js</literal
> per estendere &kappname; con script di supporto a piacere. </para>

<para
>Gli script da riga di comando si trovano nella stessa cartella degli script di rientro. Come primo passo, crea un nuovo file <filename
>*.js</filename
> chiamato <filename
>myutils.js</filename
> nella home locale <filename
>$<envar
>XDG_DATA_HOME</envar
>/katepart5/script/commands</filename
>. Al suo interno la variabile di ambiente <envar
>XDG_DATA_HOME</envar
> viene tipicamente espansa sia in <filename
>~/.local</filename
> che in <filename
>~/.local/share</filename
>.</para>
<para
>In &Windows; questi file si trovano in <filename
>%USER%\AppData\Local\katepart5\commands</filename
>. <replaceable
>%USER%</replaceable
> viene generalmente espanso in <filename
>C:\\Users\\<replaceable
>user</replaceable
></filename
>. </para>

<sect3 id="dev-scripting-command-line-header">
<title
>L'intestazione dello script per la riga di comando</title>
<para
>L'intestazione di ciascuno script da riga di comando è incorporata in JSON all'inizio dello script come segue: <programlisting>
var katescript = {
    "author": "Example Name &lt;example.name@some.address.org&gt;",
    "license": "LGPLv2+",
    "revision": 1,
    "kate-version": "5.1",
    "functions": ["sort", "moveLinesDown"],
    "actions": [
        {   "function": "sort",
            "name": "Ordina il testo selezionato",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Sposta le righe in basso",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
}; // l'intestazione dello script di kate deve essere all'inizio del file senza commento
</programlisting
> Ciascuna voce è spiegata ora in dettaglio: <itemizedlist>
<listitem
><para
><literal
>author</literal
> [facoltativo]: il nome dell'autore e informazioni per contattarlo.</para
></listitem>
<listitem
><para
><literal
>license</literal
> [facoltativo]: forma breve della licenza, come Licenza BSD o LGPLv2.</para
></listitem>
<listitem
><para
><literal
>revision</literal
> [obbligatorio]: la revisione dello script. Questo numero va aumentato ad ogni sua modifica.</para
></listitem>
<listitem
><para
><literal
>kate-version</literal
> [obbligatorio]: versione minima di &kappname; richiesta.</para
></listitem>
<listitem
><para
><literal
>functions</literal
> [obbligatorio]: vettore JSON di comandi nello script.</para
></listitem>
<listitem
><para
><literal
>actions</literal
> [opzionale]: un vettore JSON di oggetti JSON che definiscono le azioni che appaiono nel menu dell'applicazione. Informazioni dettagliate sono fornite nella sezione <link linkend="advanced-editing-tools-commandline"
>Stabilire le scorciatoie</link
>.</para
></listitem>
</itemizedlist>
</para>

<para
>Dal momento che il valore di <literal
>functions</literal
> è un vettore JSON, un singolo script può contenere un numero arbitrario di comandi per la riga di comando. Ciascuna funzione è disponibile attraverso il menu <link linkend="advanced-editing-tools-commandline"
>riga di comando integrata</link
> di &kappname;. </para>
</sect3>

<sect3 id="dev-scripting-command-line-body">
<title
>Il codice sorgente dello script</title>

<para
>Tutte le funzioni specificate nell'intestazione devono essere implementate nello script. Lo script nell'esempio qui sopra deve implementare le due funzioni <command
>sort</command
> e <command
>moveLinesDown</command
>. Tutte le funzioni hanno la sintassi seguente: <programlisting
>// librerie katepart js necessarie, per esempio range.js se usi Range
require ("range.js");

function &lt;nome&gt;(argomento_1, argomento_2, ...)
{
    // ... implementazione, vedi anche: API per gli script
}
</programlisting>
</para>

<para
>Gli argomenti nella riga di comando vengono passati alla funzione come <parameter
>argomento_1</parameter
>, <parameter
>argomento_2</parameter
>, ecc. Per poter documentare ogni comando, basta implementare la funzione <function
>help</function
> come segue: <programlisting>
function help(comando)
{
    if (comando == "sort") {
        return i18n("Ordina il testo selezionato.");
    } else if (comando == "...") {
        // ...
    }
}
</programlisting
> Eseguire quindi <command
>help sort</command
> nella riga di comando chiamerà questa funzione ausiliaria con l'argomento <parameter
>comando</parameter
> impostato al comando dato, &ie; <parameter
>comando == "sort"</parameter
>. &kappname; presenterà quindi il testo risultante come documentazione per l'utente. Assicurati di <link linkend="dev-scripting-api-i18n"
>tradurre le stringhe</link
>. </para>

<para
>Lo sviluppo di uno script da riga di comando richiede il ricaricamento gli script stesso, per testare le modifiche. Invece di riavviare l'applicazione puoi però passare alla riga di comando, e digitare il comando <command
>reload-scripts</command
>. </para>

<sect4 id="dev-scripting-command-line-shortcuts">
<title
>Stabilire le scorciatoie</title>
<para
>Per rendere gli script accessibili nel menu dell'applicazione e per potergli assegnare delle scorciatoie, gli script devono fornire un'appropriata intestazione. Nell'esempio sottostante entrambe le funzioni <literal
>sort</literal
> e <literal
>moveLinesDown</literal
> appaiono nel menu grazie alla seguente parte dell'intestazione dello script: <programlisting>
var katescript = {
    ...
    "actions": [
        {   "function": "sort",
            "name": "Ordina il testo selezionato",
            "icon": "",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Sposta le righe in basso",
            "icon": "",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
};
</programlisting
> I campi necessari sono i seguenti: <itemizedlist>
<listitem
><para
><literal
>function</literal
> [obbligatorio]: la funzione che dovrebbe comparire nel menu <menuchoice
><guimenu
>Strumenti</guimenu
><guisubmenu
>Script</guisubmenu
></menuchoice
>.</para
></listitem>
<listitem
><para
><literal
>name</literal
> [obbligatorio]: il testo che compare nel menu script.</para
></listitem>
<listitem
><para
><literal
>icon</literal
> [facoltativo]: l'icona che appare di fianco al testo nel menu. Qui si possono usare tutti i nomi delle icone di &kde;.</para
></listitem>
<listitem
><para
><literal
>category</literal
> [facoltativo]: se si specifica una categoria, lo script compare in un sottomenu.</para
></listitem>
<listitem
><para
><literal
>shortcut</literal
> [facoltativo]: la scorciatoia qui data è la predefinita, per esempio <literal
>Ctrl+Alt+t</literal
>. Vedi la <ulink url="http://qt-project.org/doc/qt-5/qt.html#Key-enum"
>documentazione di Qt</ulink
> per maggiori dettagli.</para
></listitem>
<listitem
><para
><literal
>interactive</literal
> [facoltativo]: impostalo a <literal
>true</literal
> se allo script serve che l'utente faccia qualcosa.</para
></listitem>
</itemizedlist>
</para>

<para
>Se sviluppi degli script utili, per piacere considera la possibilità di contribuirli al progetto &kappname; <ulink url="mailto:kwrite-devel@kde.org"
>contattando la lista di distribuzione</ulink
>. </para>

</sect4>
</sect3>
</sect2>

<sect2 id="dev-scripting-api">
<title
>API per gli script</title>

<para
>L'API per script qui presentata è disponibile in tutti gli script, cioè gli script di rientro e i comandi da riga di comando. Le classi <classname
>Cursor</classname
> e <classname
>Range</classname
> sono fornite dalle librerie presenti in <filename
>$<envar
>XDG_DATA_DIRS</envar
>/katepart5/libraries</filename
>. Se le vuoi usare nel tuo script, il che è necessario per usare alcune delle funzioni di <classname
>Document</classname
> o <classname
>View</classname
>, includi la libreria necessaria con: <programlisting
>// librerie katepart js necessarie, per esempio range.js se usi Range
require ("range.js");
</programlisting>
</para>

<para
>Per estendere l'API standard per gli script con funzioni e prototipi propri basta creare un nuovo file nella cartella di configurazione locale di &kde;, <filename
>$<envar
>XDG_DATA_HOME</envar
>/katepart5/libraries</filename
>, e includerlo nel tuo script con: <programlisting
>require ("nome_del_mio_script.js");
</programlisting>

</para>

<para
>In &Windows; questi file si trovano in <filename
>%USER%\AppData\Local\katepart5\libraries</filename
>. <replaceable
>%USER%</replaceable
> viene generalmente espanso in <filename
>C:\\Users\\<replaceable
>user</replaceable
></filename
>.</para>

<para
>Per estendere i prototipi preesistenti, come <classname
>Cursor</classname
> o <classname
>Range</classname
>, il modo raccomandato di procedere <emphasis
>non</emphasis
> è di modificare i file <literal role="extension"
>*.js</literal
> globali. Cambia piuttosto il prototipo <classname
>Cursor</classname
> in JavaScript dopo aver incluso <filename
>cursor.js</filename
> nello script con <literal
>require</literal
>. </para>

<sect3 id="dev-scripting-api-prototypes">
<title
>Cursori e intervalli</title>

<para
>Essendo &kappname; un editor di testo, tutta l'API per gli script si basa, ovunque sia possibile, su cursori e intervalli. Un cursore (<classname
>Cursor</classname
>) è una semplice tupla del tipo <literal
>(riga, colonna)</literal
> che rappresenta una posizione nel testo del documento. Un intervallo (<classname
>Range</classname
>) si estende sul testo a partire da una posizione di partenza a una finale del cursore. L'API viene spiegata in dettaglio nelle sezioni seguenti. </para>

<sect4 id="dev-scripting-api-cursors">
<title
>Il prototipo dei cursori</title>

<variablelist
><varlistentry>
<term
><synopsis
>Cursor();
</synopsis
></term>
<listitem
><para
>Costruttore. Restituisce un cursore alla posizione <literal
>(0, 0)</literal
>.</para>
<para
>Esempio: <function
>var cursore = new Cursor();</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Costruttore. Restituisce un cursore alla posizione <literal
>(riga, colonna)</literal
>. </para>
<para
>Esempio: <function
>var cursore = new Cursor(3, 42);</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor(<parameter
>Cursor <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Costruttore di copia. Restituisce una copia dell'<replaceable
>altro</replaceable
> cursore. </para>
<para
>Esempio: <function
>var copia = new Cursor(altro);</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor Cursor.clone();
</synopsis
></term>
<listitem
><para
>Restituisce un clone del cursore.</para>
<para
>Esempio: <function
>var clone = cursor.clone();</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor.setPosition(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta la posizione del cursore a <replaceable
>riga</replaceable
> e <replaceable
>colonna</replaceable
>.</para>
<para
>Da: &kde; 4.11 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Cursor.isValid();
</synopsis
></term>
<listitem
><para
>Controlla se il cursore è valido. Non lo è se la riga o la colonna sono impostate a <literal
>-1</literal
>. </para>
<para
>Esempio: <function
>var valido = cursor.isValid();</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor Cursor.invalid();
</synopsis
></term>
<listitem
><para
>Restituisce un nuovo cursore non valido posizionato a <literal
>(-1, -1)</literal
>. </para>
<para
>Esempio: <function
>var cursoreNonValido = cursor.invalid();</function
> </para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>int Cursor.compareTo(<parameter
>Cursor <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Confronta un cursore con un <replaceable
>altro</replaceable
>. Restituisce: <itemizedlist>
<listitem
><para
><literal
>-1</literal
>, se il cursore è posizionato prima dell'<replaceable
>altro</replaceable
>,</para
></listitem>
<listitem
><para
><literal
>0</literal
>, se sono uguali, e</para
></listitem>
<listitem
><para
><literal
>+1</literal
>, se il cursore è posizionato dopo l'<replaceable
>altro</replaceable
>.</para
></listitem>
</itemizedlist>
</para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Cursor.equals(<parameter
>Cursor <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il cursore e l'<replaceable
>altro</replaceable
> sono uguali, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String Cursor.toString();
</synopsis
></term>
<listitem
><para
>Restituisce un cursore sotto forma di stringa nella forma <quote
><literal
>Cursor(riga, colonna)</literal
></quote
>. </para
></listitem>
</varlistentry
></variablelist>

</sect4>


<sect4 id="dev-scripting-api-ranges">
<title
>Il prototipo degli intervalli</title>

<variablelist
><varlistentry>
<term
><synopsis
>Range();
</synopsis
></term>
<listitem
><para
>Costruttore. Chiamare <userinput
>new Range()</userinput
> restituisce un intervallo tra <literal
>(0, 0)</literal
> e <literal
>(0, 0)</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range(<parameter
>Cursor <replaceable
>inizio</replaceable
></parameter
>, <parameter
>Cursor <replaceable
>fine</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Costruttore. Chiamare <literal
>new Range(<replaceable
>inizio</replaceable
>, <replaceable
>fine</replaceable
>)</literal
> restituisce l'intervallo (<replaceable
>inizio</replaceable
>, <replaceable
>fine</replaceable
>). </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range(<parameter
>int <replaceable
>riga_inizio</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna_inizio</replaceable
></parameter
>, <parameter
>int <replaceable
>riga_fine</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna_fine</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Costruttore. Chiamare <literal
>new Range(<replaceable
>riga_inizio</replaceable
>, <replaceable
>colonna_inizio</replaceable
>, <replaceable
>riga_fine</replaceable
>, <replaceable
>colonna_fine</replaceable
>)</literal
> restituisce l'intervallo da (<replaceable
>riga_inizio</replaceable
>, <replaceable
>colonna_inizio</replaceable
>) a (<replaceable
>riga_fine</replaceable
>, <replaceable
>colonna_fine</replaceable
>). </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range(<parameter
>Range <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Costruttore di copia. Restituisce una copia dell'<replaceable
>altro</replaceable
> intervallo. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range Range.clone();
</synopsis
></term>
<listitem
><para
>Restituisce un clone dell'intervallo. </para>
<para
>Esempio: <function
>var clone = range.clone();</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.isEmpty();
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se i cursori di inizio e fine sono uguali. </para>
<para
>Esempio: <function
>var empty = range.isEmpty();</function
> </para>
<para
>Da: &kde; 4.11 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.isValid();
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se entrambi i cursori, iniziale e finale, sono validi, altrimenti <literal
>false</literal
>. </para>
<para
>Esempio: <function
>var valido = range.isValid();</function
> </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range Range.invalid();
</synopsis
></term>
<listitem
><para
>Restituisce l'intervallo da (-1, -1) a (-1, -1). </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.contains(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'intervallo contiene la posizione del <replaceable
>cursore</replaceable
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.contains(<parameter
>Range <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'intervallo contiene l'<replaceable
>altro</replaceable
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.containsColumn(<parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>colonna</replaceable
> è nell'intervallo semiaperto <literal
>[inizio.colonna, fine.colonna)</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.containsLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>riga</replaceable
> è nell'intervallo semiaperto <literal
>[inizio.riga, fine.riga)</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.overlaps(<parameter
>Range <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'intervallo e l'<replaceable
>altro</replaceable
> hanno una regione in comune, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.overlapsLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>riga</replaceable
> è nell'intervallo <literal
>[inizio.riga, fine.riga]</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.overlapsColumn(<parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>colonna</replaceable
> è nell'intervallo <literal
>[inizio.colonna, fine.colonna]</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.onSingleLine();
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'intervallo comincia e finisce sulla stessa riga, &ie; se <replaceable
>Range.start.line == Range.end.line</replaceable
>. </para>
<para
>Da: &kde; 4.9 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool Range.equals(<parameter
>Range <replaceable
>altro</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'intervallo e l'<replaceable
>altro</replaceable
> sono uguali, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String Range.toString();
</synopsis
></term>
<listitem
><para
>Restituisce un intervallo sotto forma di stringa nella forma <quote
><literal
>Range(Cursor(riga, colonna), Cursor(riga, colonna))</literal
></quote
>. </para
></listitem>
</varlistentry
></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-global">
<title
>Funzioni globali</title>
<para
>Questa sezione elenca tutte le funzioni globali.</para>


<sect4 id="dev-scripting-api-includes">
<title
>Leggere e includere file</title>

<variablelist
><varlistentry>
<term
><synopsis
>String read(<parameter
>String <replaceable
>file</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Cercherà nel <replaceable
>file</replaceable
> dato, relativamente alla cartella <literal
>katepart/script/files</literal
>, e ne restituirà i contenuti in forma di stringa. </para
></listitem>
</varlistentry
></variablelist>

<variablelist
><varlistentry>
<term
><synopsis
>void require(<parameter
>String <replaceable
>file</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Cercherà nel <replaceable
>file</replaceable
> dato, relativamente alla cartella <literal
>katepart/script/libraries</literal
>, e lo valuterà. <literal
>require</literal
> è già programmato per evitare inclusioni multiple dello stesso <replaceable
>file</replaceable
>. </para>
<para
>Da: &kde; 4.10 </para>
</listitem>
</varlistentry
></variablelist>

</sect4>

<sect4 id="dev-scripting-api-debug">
<title
>Debug</title>

<variablelist
><varlistentry>
<term
><synopsis
>void debug(<parameter
>String <replaceable
>testo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Stampa il <replaceable
>testo</replaceable
> su <literal
>stdout</literal
> nella console che ha avviato l'applicazione. </para
></listitem>
</varlistentry
></variablelist>

</sect4>

<sect4 id="dev-scripting-api-i18n">
<title
>Traduzione</title>

<para
>Per supportare una localizzazione completa ci sono diverse funzioni per tradurre le stringhe negli script, cioè <literal
>i18n</literal
>, <literal
>i18nc</literal
>, <literal
>i18np</literal
> e <literal
>i18ncp</literal
>. Queste funzioni si comportano esattamente come le <ulink url="http://techbase.kde.org/Development/Tutorials/Localization/i18n"
>funzioni di traduzione di &kde;</ulink
>. </para>

<para
>Le funzioni traducono le stringhe incluse con il sistema di traduzione di &kde; nella lingua usata nell'applicazione. Le stringhe negli script sviluppati nel codice sorgente ufficiale di &kappname; sono automaticamente estratte e traducibili: in altre parole gli sviluppatori di &kappname; non devono preoccuparsi di estrarre e tradurre i messaggi. Va anche notato, però, che la traduzione funziona solo all'interno dell'infrastruttura di &kde;: &ie; nuove stringhe negli script di terze parti sviluppati al di fuori di &kde; non sarebbero tradotte. Tuttavia prendi in considerazione l'idea di contribuire con i tuoi script a &kate;, in modo che sia possibile una traduzione appropriata. </para>

<variablelist
><varlistentry>
<term
><synopsis
>void i18n(<parameter
>String <replaceable
>testo</replaceable
></parameter
>, <replaceable
>argomento_1</replaceable
>, ... );
</synopsis
></term>
<listitem
><para
>Traduce <replaceable
>testo</replaceable
> nella lingua usata dall'applicazione. Gli argomenti <replaceable
>argomento_1</replaceable
> e seguenti sono facoltativi e vengono usati per sostituire i segnaposti <literal
>%1</literal
>, <literal
>%2</literal
>, e così via.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>void i18nc(<parameter
>String <replaceable
>contesto</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>, <replaceable
>argomento_1</replaceable
>, ... );
</synopsis
></term>
<listitem
><para
>Traduce <replaceable
>testo</replaceable
> nella lingua usata dall'applicazione. Inoltre, la stringa <replaceable
>contesto</replaceable
> viene resa visibile ai traduttori, per chiarire eventuali equivoci e produrre una traduzione migliore. Gli argomenti <replaceable
>argomento_1</replaceable
> e seguenti sono facoltativi, e vengono usati per sostituire i segnaposti <literal
>%1</literal
>, <literal
>%2</literal
> e così via.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>void i18np(<parameter
>String <replaceable
>singolare</replaceable
></parameter
>, <parameter
>String <replaceable
>plurale</replaceable
></parameter
>, <parameter
>int <replaceable
>numero</replaceable
></parameter
>, <replaceable
>argomento_1</replaceable
>, ... );
</synopsis
></term>
<listitem
><para
>Traduce <replaceable
>singolare</replaceable
> o <replaceable
>plurale</replaceable
> nella lingua usata dall'applicazione, a seconda del <replaceable
>numero</replaceable
> dato. Gli argomenti <replaceable
>argomento_1</replaceable
> e seguenti sono facoltativi, e vengono usati per sostituire i segnaposti <literal
>%1</literal
>, <literal
>%2</literal
> e così via.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>void i18ncp(<parameter
>String <replaceable
>contesto</replaceable
></parameter
>, <parameter
>String <replaceable
>singolare</replaceable
></parameter
>, <parameter
>String <replaceable
>plurale</replaceable
></parameter
>, <parameter
>int <replaceable
>numero</replaceable
></parameter
>, <replaceable
>argomento_1</replaceable
>, ... );
</synopsis
></term>
<listitem
><para
>Traduce <replaceable
>singolare</replaceable
> o <replaceable
>plurale</replaceable
> nella lingua usata dall'applicazione, a seconda del <replaceable
>numero</replaceable
> dato. Inoltre la stringa <replaceable
>contesto</replaceable
> viene resa visibile ai traduttori, per chiarire eventuali equivoci e produrre una traduzione migliore. Gli argomenti <replaceable
>argomento_1</replaceable
> e seguenti sono facoltativi, e vengono usati per sostituire i segnaposti <literal
>%1</literal
>, <literal
>%2</literal
> e così via.</para
></listitem>
</varlistentry
></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-view">
<title
>L'API delle viste</title>
<para
>Ogni volta che uno script viene eseguito è presente una variabile globale, <quote
><literal
>view</literal
></quote
>, che rappresenta la vista attiva dell'editor. Segue un elenco di tutte le funzioni di vista disponibili. <variablelist
><varlistentry>
<term
><synopsis
><function
>Cursor view.cursorPosition()</function
>
</synopsis
></term>
<listitem
><para
>Restituisce la posizione attuale del cursore nella vista.</para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.setCursorPosition(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
void view.setCursorPosition(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta la posizione attuale del cursore a <literal
>(<replaceable
>riga</replaceable
>, <replaceable
>colonna</replaceable
>)</literal
> o al <replaceable
>cursore</replaceable
> dato. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor view.virtualCursorPosition();
</synopsis
></term>
<listitem
><para
>Restituisce la posizione virtuale del cursore con ogni tabulazione che conta una quantità di spazi dipendente dall'attuale ampiezza di tabulazione. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.setVirtualCursorPosition(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
void view.setVirtualCursorPosition(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta la posizione virtuale attuale del cursore a <literal
>(<replaceable
>riga</replaceable
>, <replaceable
>colonna</replaceable
>)</literal
> o al <replaceable
>cursore</replaceable
> dato. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String view.selectedText();
</synopsis
></term>
<listitem
><para
>Restituisce il testo selezionato. Se non c'è del testo selezionato, la stringa restituita è vuota. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool view.hasSelection();
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la vista contiene del testo selezionato, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range view.selection();
</synopsis
></term>
<listitem
><para
>Restituisce l'intervallo di testo selezionato. L'intervallo di testo non è valido se non c'è testo selezionato. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.setSelection(<parameter
>Range <replaceable
>intervallo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta il testo selezionato all'<replaceable
>intervallo</replaceable
> dato. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.removeSelectedText();
</synopsis
></term>
<listitem
><para
>Rimuove il testo selezionato. Se la vista non ne ha non fa nulla. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.selectAll();
</synopsis
></term>
<listitem
><para
>Seleziona tutto il testo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void view.clearSelection();
</synopsis
></term>
<listitem
><para
>Pulisce la selezione di testo senza rimuoverlo. </para
></listitem>
</varlistentry
></variablelist>
</para>
</sect3>

<sect3 id="dev-scripting-api-document">
<title
>L'API dei documenti</title>
<para
>Ogni volta che uno script viene eseguito è presente una variabile globale, <quote
><literal
>document</literal
></quote
>, che rappresenta il documento attivo. Segue un elenco di tutte le funzioni del documento disponibili. <variablelist
><varlistentry>
<term
><synopsis
>String document.fileName();
</synopsis
></term>
<listitem
><para
>Restituisce il nome del file del documento o una stringa vuota per i documenti non salvati. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.url();
</synopsis
></term>
<listitem
><para
>Restituisce l'URL completo del documento, o una stringa vuota per i documenti non salvati. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.mimeType();
</synopsis
></term>
<listitem
><para
>Restituisce il tipo di file del documento, o il tipo di file <literal
>application/octet-stream</literal
> se non se ne può trovare uno appropriato. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.encoding();
</synopsis
></term>
<listitem
><para
>Restituisce la codifica attualmente usata per salvare il file. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>String document.highlightingMode();
</synopsis
></term>
<listitem
><para
>Restituisce la modalità di evidenziazione globale usata per tutto il documento. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>String document.highlightingModeAt(<parameter
>Cursor <replaceable
>posizione</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la modalità di evidenziazione usata alla <replaceable
>posizione</replaceable
> nel documento. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>Array document.embeddedHighlightingModes();
</synopsis
></term>
<listitem
><para
>Restituisce un array di modalità di evidenziazione incorporate in questo documento. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><synopsis
>bool document.isModified();
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il documento ha modifiche non salvate, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.text();
</synopsis
></term>
<listitem
><para
>Restituisce tutto il contenuto del documento in una sola stringa di testo. I ritorni a capo sono indicati con il carattere <quote
><literal
>\n</literal
></quote
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.text(<parameter
>int <replaceable
>da_riga</replaceable
></parameter
>, <parameter
>int <replaceable
>da_colonna</replaceable
></parameter
>, <parameter
>int <replaceable
>a_riga</replaceable
></parameter
>, <parameter
>int <replaceable
>a_colonna</replaceable
></parameter
>);
String document.text(<parameter
>Cursor <replaceable
>da</replaceable
></parameter
>, <parameter
>Cursor <replaceable
>a</replaceable
></parameter
>);
String document.text(<parameter
>Range <replaceable
>intervallo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce il testo nell'intervallo dato. Per migliorare la leggibilità del codice si raccomanda di usare le versioni con cursori o intervalli. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.line(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la riga di testo richiesta come stringa. La stringa è vuota se la riga richiesta è oltre i limiti. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.wordAt(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
String document.wordAt(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la parola alla posizione del cursore data. </para
></listitem>
</varlistentry>


<varlistentry>
<term>
<synopsis
>Range document.wordRangeAt(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
Range document.wordRangeAt(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis>
</term>
<listitem
><para
>Restituisce l'intervallo di una parola alla posizione del cursore data. L'intervallo restituito non è valido (vedi Range.isValid()) se la posizione è oltre la fine di una riga. Se non c'è una parola alla fine del cursore viene restituito un intervallo vuoto. </para>
<para
>Da: &kde; 4.9 </para>
</listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.charAt(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
String document.charAt(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce il carattere alla posizione del cursore data. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.firstChar(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce il primo carattere nella <replaceable
>riga</replaceable
> data che non sia uno spazio. Il primo carattere è alla colonna 0. Se la riga è vuota o contiene solo spazi la stringa restituita è vuota. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.lastChar(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'ultimo carattere nella <replaceable
>riga</replaceable
> data che non sia uno spazio. Se la riga è vuota o contiene solo spazi la stringa restituita è vuota. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isSpace(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isSpace(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il carattere alla posizione del cursore data è uno spazio, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.matchesAt(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>);
bool document.matchesAt(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il <replaceable
>testo</replaceable
> corrisponde a quello presente alla posizione del cursore, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.startsWith(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>, <parameter
>bool <replaceable
>salta_spazi</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la riga comincia con il <replaceable
>testo</replaceable
>, altrimenti <literal
>false</literal
>. L'argomento <replaceable
>salta_spazi</replaceable
> decide se gli spazi iniziali vanno ignorati. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.endsWith(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>, <parameter
>bool <replaceable
>salta_spazi</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la riga finisce con il <replaceable
>testo</replaceable
>, altrimenti <literal
>false</literal
>. L'argomento <replaceable
>salta_spazi</replaceable
> decide se gli spazi finali vanno ignorati. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.setText(<parameter
>String <replaceable
>testo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta tutto il testo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.clear();
</synopsis
></term>
<listitem
><para
>Rimuove tutto il testo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.truncate(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.truncate(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Tronca la <replaceable
>riga</replaceable
> alla <replaceable
>colonna</replaceable
>. Restituisce <literal
>true</literal
> se funziona, o <literal
>false</literal
> se la <replaceable
>riga</replaceable
> non fa parte dell'intervallo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.insertText(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>);
bool document.insertText(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Inserisce il <replaceable
>testo</replaceable
> alla posizione del cursore data. Restituisce <literal
>true</literal
> se funziona, o <literal
>false</literal
> se il documento è in modalità a sola lettura. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.removeText(<parameter
>int <replaceable
>da_riga</replaceable
></parameter
>, <parameter
>int <replaceable
>da_colonna</replaceable
></parameter
>, <parameter
>int <replaceable
>a_riga</replaceable
></parameter
>, <parameter
>int <replaceable
>a_colonna</replaceable
></parameter
>);
bool document.removeText(<parameter
>Cursor <replaceable
>da</replaceable
></parameter
>, <parameter
>Cursor <replaceable
>a</replaceable
></parameter
>);
bool document.removeText(<parameter
>Range <replaceable
>intervallo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Rimuove il testo nell'intervallo dato. Restituisce <literal
>true</literal
> se funziona, o <literal
>false</literal
> se il documento è in modalità di sola lettura. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.insertLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Inserisce il testo nella riga data. Restituisce <literal
>true</literal
> se funziona, o <literal
>false</literal
> se il documento è in modalità di sola lettura oppure la riga non è nell'intervallo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.removeLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Rimuove la riga di testo data. Restituisce <literal
>true</literal
> se funziona, o <literal
>false</literal
> se il documento è in modalità di sola lettura oppure la riga non è nell'intervallo del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.wrapLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.wrapLine(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Manda a capo la riga alla posizione del cursore data. Restituisce <literal
>true</literal
> se funziona, altrimenti <literal
>false</literal
>, &eg; se la riga &lt; 0. </para>
<para
>Da: &kde; 4.9 </para>
</listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void document.joinLines(<parameter
>int <replaceable
>riga_inizio</replaceable
></parameter
>, <parameter
>int <replaceable
>riga_fine</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Unisce le righe da <replaceable
>riga_inizio</replaceable
> a <replaceable
>riga_fine</replaceable
>. Due righe di testo consecutive sono sempre separate da un solo spazio. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.lines();
</synopsis
></term>
<listitem
><para
>Restituisce il numero di righe nel documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isLineModified(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>riga</replaceable
> attuale contiene dati non salvati. </para>
<para
>Da: &kde; 5.0 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isLineSaved(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>riga</replaceable
> è cambiata ma il documento è stato salvato, e quindi la riga corrente non contiene dati non salvati. </para>
<para
>Da: &kde; 5.0 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isLineTouched(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la <replaceable
>riga</replaceable
> contiene dati non salvati o è stata cambiata in precedenza. </para>
<para
>Da: &kde; 5.0 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.findTouchedLine(<parameter
>int <replaceable
>startLine</replaceable
></parameter
>, <parameter
>bool <replaceable
>giù</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Cerca la successiva riga modificata, a partire da <replaceable
>riga</replaceable
>. La ricerca è eseguita verso l'alto o verso il basso, a seconda della direzione specificata in <replaceable
>giù</replaceable
>. </para>
<para
>Da: &kde; 5.0 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.length();
</synopsis
></term>
<listitem
><para
>Restituisce il numero di caratteri nel documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.lineLength(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la lunghezza della <replaceable
>riga</replaceable
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void document.editBegin();
</synopsis
></term>
<listitem
><para
>Avvia un gruppo di modifica per un raggruppamento di azioni annullabili. Assicurati di chiamare sempre <function
>editEnd()</function
> con la stessa frequenza di <function
>editBegin()</function
>. Chiamando <function
>editBegin</function
> viene usato internamente un contatore di riferimenti, &ie;, questa chiamata può essere annidata. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void document.editEnd();
</synopsis
></term>
<listitem
><para
>Chiude un gruppo di modifica. L'ultima chiamata di <function
>editEnd()</function
> (&ie; quella corrispondente alla prima chiamata a <function
>editBegin()</function
>) conclude il passo di modifica. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.firstColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la prima colonna non di spazi nella <replaceable
>riga</replaceable
>. Se nella <replaceable
>riga</replaceable
> ci sono solo spazi, viene restituito <literal
>-1</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.lastColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'ultima colonna non di spazi nella <replaceable
>riga</replaceable
>. Se nella <replaceable
>riga</replaceable
> ci sono solo spazi, viene restituito <literal
>-1</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.prevNonSpaceColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
int document.prevNonSpaceColumn(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la colonna con caratteri non di spaziatura che comincia alla posizione del cursore data, cercando indietro. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.nextNonSpaceColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
int document.nextNonSpaceColumn(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la colonna con caratteri non di spaziatura che comincia alla posizione del cursore data, cercando in avanti. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.prevNonEmptyLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la prossima riga non vuota con caratteri non di spaziatura, cercando indietro. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.nextNonEmptyLine(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la prossima riga non vuota con caratteri non di spaziatura, cercando in avanti. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isInWord(<parameter
>String <replaceable
>carattere</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il <replaceable
>carattere</replaceable
> con l'<replaceable
>attributo</replaceable
> può far parte di una parola, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.canBreakAt(<parameter
>String <replaceable
>carattere</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il <replaceable
>carattere</replaceable
> con l'<replaceable
>attributo</replaceable
> può essere mandato a capo, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.canComment(<parameter
>int <replaceable
>attributo_inizio</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo_fine</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se un intervallo che inizia e finisce con gli attributi dati può essere fatto diventare un commento, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.commentMarker(<parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'indicatore di commento per i commenti di una sola riga per un <replaceable
>attributo</replaceable
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.commentStart(<parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'indicatore di commento per l'inizio di commenti multi-riga per un <replaceable
>attributo</replaceable
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.commentEnd(<parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'indicatore di commento per la fine di commenti multi-riga per un <replaceable
>attributo</replaceable
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Range document.documentRange();
</synopsis
></term>
<listitem
><para
>Restituisce un intervallo che comprende tutto il documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor documentEnd();
</synopsis
></term>
<listitem
><para
>Restituisce un cursore posizionato nell'ultima colonna dell'ultima riga del documento. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool isValidTextPosition(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool isValidTextPosition(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se la posizione del cursore ricade in una posizione di testo valida, cioè se è localizzata all'inizio, nel mezzo o alla fine di una riga valida. Una posizione di testo non è valida se si trova in un surrogato Unicode. </para
><para
>Da: &kde; 5.0 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.attribute(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
int document.attribute(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce l'attributo alla posizione del cursore data. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isAttribute(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
bool document.isAttribute(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo alla posizione del cursore data è uguale a <replaceable
>attributo</replaceable
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.attributeName(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
String document.attributeName(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce il nome dell'attributo in testo leggibile. È uguale al nome <literal
>itemData</literal
> nei file di evidenziazione della sintassi. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isAttributeName(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>String <replaceable
>nome</replaceable
></parameter
>);
bool document.isAttributeName(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>String <replaceable
>nome</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se il nome dell'attributo a una certa posizione del cursore corrisponde al <replaceable
>nome</replaceable
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>String document.variable(<parameter
>String <replaceable
>chiave</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce il valore della variabile del documento <replaceable
>chiave</replaceable
>. Se la variabile non esiste il valore restituito è una stringa vuota. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>void document.setVariable(<parameter
>String <replaceable
>chiave</replaceable
></parameter
>, <parameter
>String <replaceable
>valore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Imposta il valore della variabile del documento richiesta <replaceable
>chiave</replaceable
>. </para>
<para
>Vedi anche: <link linkend="config-variables"
>le variabili nei documenti di Kate</link
>. </para>
<para
>Da: &kde; 4.8 </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.firstVirtualColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la colonna virtuale del primo carattere non di spaziatura nella riga indicata, o <literal
>-1</literal
> se la riga è vuota oppure contiene solo caratteri di spaziatura. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.lastVirtualColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce la colonna virtuale dell'ultimo carattere non di spaziatura nella riga indicata, o <literal
>-1</literal
> se la riga è vuota oppure contiene solo caratteri di spaziatura. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.toVirtualColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
int document.toVirtualColumn(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
Cursor document.toVirtualCursor(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Converte la posizione <quote
>reale</quote
> del cursore in una virtuale, restituendo un oggetto <classname
>int</classname
> o <classname
>Cursor</classname
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.fromVirtualColumn(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna_virtuale</replaceable
></parameter
>);
int document.fromVirtualColumn(<parameter
>Cursor <replaceable
>cursore_virtuale</replaceable
></parameter
>);
Cursor document.fromVirtualCursor(<parameter
>Cursor <replaceable
>cursore_virtuale</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Converte la posizione virtuale data del cursore in una <quote
>reale</quote
>, restituendo un oggetto <classname
>int</classname
> o <classname
>Cursor</classname
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor document.anchor(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>Char <replaceable
>carattere</replaceable
></parameter
>);
Cursor document.anchor(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>Char <replaceable
>carattere</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Cerca indietro il carattere partendo dal cursore dato. Per esempio, se si passa «(» come carattere, la funzione restituirà la posizione dell'apertura «(». Questo conteggio dei riferimenti, &ie; altri «(...)», vengono ignorati. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>Cursor document.rfind(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
> = -1</parameter
>);
Cursor document.rfind(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>, <parameter
>String <replaceable
>testo</replaceable
></parameter
>, <parameter
>int <replaceable
>attributo</replaceable
> = -1</parameter
>);
</synopsis
></term>
<listitem
><para
>Cerca all'indietro il testo con l'<replaceable
>attributo</replaceable
> appropriato. L'<replaceable
>attributo</replaceable
> viene ignorato se è impostato a <literal
>-1</literal
>. Il cursore restituito non è valido se non si trova il testo. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>int document.defStyleNum(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
int document.defStyleNum(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce lo stile predefinito usato alla posizione data del cursore. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isCode(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isCode(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo alla posizione data del cursore non è uguale a tutti i seguenti stili: <literal
>dsComment</literal
>, <literal
>dsString</literal
>, <literal
>dsRegionMarker</literal
>, <literal
>dsChar</literal
>, <literal
>dsOthers</literal
>. </para
></listitem>
</varlistentry>



<varlistentry>
<term
><synopsis
>bool document.isComment(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isComment(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo del carattere alla posizione del cursore data è <literal
>dsComment</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isString(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isString(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo del carattere alla posizione del cursore data è <literal
>dsString</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isRegionMarker(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isRegionMarker(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo del carattere alla posizione del cursore data è <literal
>dsRegionMarker</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isChar(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isChar(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo del carattere alla posizione del cursore data è <literal
>dsChar</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry>


<varlistentry>
<term
><synopsis
>bool document.isOthers(<parameter
>int <replaceable
>riga</replaceable
></parameter
>, <parameter
>int <replaceable
>colonna</replaceable
></parameter
>);
bool document.isOthers(<parameter
>Cursor <replaceable
>cursore</replaceable
></parameter
>);
</synopsis
></term>
<listitem
><para
>Restituisce <literal
>true</literal
> se l'attributo del carattere alla posizione del cursore data è <literal
>dsOthers</literal
>, altrimenti <literal
>false</literal
>. </para
></listitem>
</varlistentry
></variablelist>
</para>

</sect3>
</sect2>

</sect1>

</chapter>
